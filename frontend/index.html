<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exam Paper Transcription Tool (LLM Concept)</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@2.16.105/build/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        .drop-area {
            border: 2px dashed #9ca3af;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: border 0.3s ease, background-color 0.3s ease;
            background-color: #f9fafb;
        }
        .drop-area:hover, .drop-area.active {
            border-color: #3b82f6;
            background-color: #eff6ff;
        }
        th {
            position: sticky;
            top: 0;
            background-color: #e5e7eb; /* gray-200 */
            z-index: 10;
        }
        button {
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        button:hover:not(:disabled) {
             box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        button:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }
        .table-container {
            max-height: 70vh;
            overflow-y: auto;
            border: 1px solid #e5e7eb;
            border-radius: 0.375rem;
            background-color: white;
        }
        .alert {
            border-radius: 0.375rem;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        #debugToggle {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background-color: rgba(229, 231, 235, 0.8);
            backdrop-filter: blur(4px);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            border: 1px solid #d1d5db;
        }
        #ocrPreviewCanvas {
            display: block;
            max-width: 100%;
            height: auto;
            margin: 0 auto;
            border: 1px solid #d1d5db;
        }
        .log-area {
            font-family: 'Menlo', 'Monaco', 'Consolas', "Liberation Mono", "Courier New", monospace;
            font-size: 0.8rem;
            line-height: 1.4;
            white-space: pre-wrap;
            word-wrap: break-word;
            background-color: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 0.375rem;
            padding: 0.75rem;
            color: #374151;
        }
        .main-content-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
        }
        @media (min-width: 1024px) {
            .main-content-grid {
                grid-template-columns: 1fr 2fr;
            }
        }
        #llmPromptDisplay {
            background-color: #eef2ff; 
            border: 1px solid #c7d2fe; 
            border-radius: 0.375rem;
            padding: 1rem;
            font-size: 0.875rem; 
            color: #4338ca; 
            white-space: pre-wrap; 
            max-height: 200px;
            overflow-y: auto;
        }
        #llmLiveOutputContainer {
            background-color: #fff;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            padding: 1rem;
            margin-top: 1rem;
        }
        #llmLiveOutput { 
            min-height: 100px;
            max-height: 400px; 
            overflow-y: auto;
        }
        .manual-input-json-label::after {
            content: " (Paste JSON from LLM tagging)";
            font-style: italic;
            font-size: 0.8em;
            color: #4b5563; /* gray-600 */
        }
         .manual-input-markdown-label::after {
            content: " (Paste Markdown Table)";
            font-style: italic;
            font-size: 0.8em;
            color: #4b5563; /* gray-600 */
        }
    </style>
</head>
<body class="min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-7xl">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-8">Exam Paper Transcription Tool (LLM Concept)</h1>

        <div class="main-content-grid">
            <div class="order-2 lg:order-1 bg-white rounded-lg shadow-md p-6 space-y-6">
                <div>
                    <h3 class="text-lg font-semibold text-gray-700 mb-3">Active LLM Prompt</h3>
                    <div id="llmPromptDisplay" class="log-area">
                        The prompt for the LLM will be displayed here.
                    </div>
                </div>
                <div>
                    <h3 class="text-lg font-semibold text-gray-700 mb-3">Live OCR Output (Current Page)</h3>
                    <div id="liveOcrText" class="log-area h-64 overflow-y-auto">
                        Waiting for page processing...
                    </div>
                </div>
                <div>
                    <h3 class="text-lg font-semibold text-gray-700 mb-3">Full Transcription Log (Input to LLM Proxy)</h3>
                    <div id="transcriptionLog" class="log-area h-96 overflow-y-auto">
                        Log will appear here...
                    </div>
                </div>
            </div>

            <div class="order-1 lg:order-2 space-y-6">
                <div class="bg-white rounded-lg shadow-md p-6">
                    <h2 class="text-xl font-semibold mb-4 text-gray-700">1. Upload Exam Paper & Process with LLM</h2>
                    <div id="dropArea" class="drop-area mb-4">
                        <p class="text-gray-600 mb-2">Drop your PDF file here or click to browse</p>
                        <p class="text-sm text-gray-500">Supported format: PDF</p>
                        <input type="file" id="fileInput" accept=".pdf" class="hidden">
                    </div>
                    <div id="fileInfo" class="mb-4 hidden flex items-center justify-between bg-gray-50 p-3 rounded-md">
                        <p class="text-sm font-medium text-gray-700">Selected file: <span id="fileName" class="text-blue-600 font-semibold"></span></p>
                        <button id="removeFile" class="text-red-600 hover:text-red-800 text-sm font-medium">Remove</button>
                    </div>
                    
                    <div class="mb-4 border-t pt-4 mt-4 space-y-4">
                        <div>
                             <h3 class="text-md font-semibold mb-2 text-gray-600">File Processing Settings</h3>
                             <div class="form-check flex items-center space-x-2 mb-2">
                                <input class="form-check-input h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500" type="checkbox" id="forceOcrCheckbox">
                                <label class="form-check-label text-sm text-gray-700" for="forceOcrCheckbox">
                                    Force OCR processing (for scanned documents)
                                </label>
                            </div>
                             <div class="form-check flex items-center space-x-2 mb-2"> <input class="form-check-input h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500" type="checkbox" id="enableLayoutAnalysisCheckbox">
                                <label class="form-check-label text-sm text-gray-700" for="enableLayoutAnalysisCheckbox">
                                    Enable Layout Analysis (Logs detailed OCR data)
                                </label>
                            </div>
                            <div class="form-check flex items-center space-x-2 ml-4"> <input class="form-check-input h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500" type="checkbox" id="showOcrBlocksCheckbox" disabled> <label class="form-check-label text-sm text-gray-700" for="showOcrBlocksCheckbox">
                                    Show OCR Detected Blocks (in Preview)
                                </label>
                            </div>
                        </div>

                        <div id="llmConfigOptions" class="space-y-3">
                            <div>
                                <h3 class="text-md font-semibold text-gray-600">LLM Selection</h3>
                                <label for="llmModelSelect" class="block text-sm font-medium text-gray-700 mb-1">Choose LLM Provider/Model:</label>
                                <select id="llmModelSelect" name="llmModel" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                                    <option value="local_ollama_Qwen3">Local LLM (Ollama - Qwen3 8B) - Streaming</option> 
                                    <option value="google_gemini_pro">Google Gemini Pro (Cloud) - Streaming</option>
                                </select>
                            </div>
                            <div id="processingModeOptions">
                                <h3 class="text-md font-semibold text-gray-600">LLM Processing Mode</h3>
                                <label for="processingModeSelect" class="block text-sm font-medium text-gray-700 mb-1">Choose how LLM output is processed:</label>
                                <select id="processingModeSelect" name="processingMode" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                                    <option value="directStructure">LLM Direct Structuring (Outputs Markdown Table)</option>
                                    <option value="tagAndAssemble">LLM Tags Content & Frontend Assembles (Outputs JSON)</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <div id="memoryWarning" class="alert bg-yellow-100 border border-yellow-300 text-yellow-800 text-sm p-3 rounded-md mb-4 hidden">
                        <p><strong>Warning:</strong> Your device has limited memory. OCR processing might be slow or unstable.</p>
                    </div>
                    <div id="ocrUnsupported" class="alert bg-red-100 border border-red-300 text-red-700 text-sm p-3 rounded-md mb-4 hidden">
                        <p><strong>Error:</strong> OCR processing requires WebAssembly support, which is not available in your browser.</p>
                    </div>
                    <button id="transcribeBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded disabled:opacity-50 w-full text-lg">
                        Transcribe & Structure with LLM
                    </button>
                </div>

                <div id="ocrPreviewContainer" class="bg-white rounded-lg shadow-md p-6 hidden">
                    <h3 class="text-lg font-semibold text-gray-700 mb-2 text-center">OCR Page Preview</h3>
                    <p id="ocrPreviewPageInfo" class="text-sm text-gray-600 text-center mb-2">Page X of Y</p>
                    <div class="relative w-full h-auto border border-gray-300 rounded overflow-hidden bg-white">
                        <canvas id="ocrPreviewCanvas"></canvas>
                    </div>
                </div>

                <div id="processingIndicator" class="alert bg-blue-100 border border-blue-300 text-blue-800 my-4 hidden">
                    <div class="flex items-center">
                        <div class="animate-spin rounded-full h-5 w-5 border-t-2 border-b-2 border-blue-500 mr-3" role="status">
                            <span class="sr-only">Processing...</span>
                        </div>
                        <div>
                            <p class="font-semibold mb-0" id="processingStatus">Processing your PDF...</p>
                            <p class="text-sm mb-0 text-blue-700" id="processingSubStatus">Initializing...</p>
                        </div>
                    </div>
                    <div id="progressBarContainer" class="mt-2"></div>
                </div>

                <div id="errorMessage" class="alert bg-red-100 border border-red-400 text-red-700 hidden">
                    <p></p>
                </div>

                <div id="llmLiveOutputContainer" class="hidden">
                    <h3 class="text-lg font-semibold text-gray-700 mb-3">Live LLM Output Stream</h3>
                    <div id="llmLiveOutput" class="log-area h-64 overflow-y-auto">Waiting for LLM stream...</div>
                </div>

                <div id="manualInputSection" class="bg-white rounded-lg shadow-md p-6 mt-6">
                    <h2 class="text-xl font-semibold text-gray-700 mb-4">2. Or, Parse Manual LLM Output</h2>
                    <p class="text-sm text-gray-600 mb-3">
                        Paste LLM output below (Markdown table or JSON tags, matching selected Processing Mode) to parse and display it.
                    </p>
                    <div>
                        <label id="manualInputLabel" for="manualMarkdownInput" class="block text-sm font-medium text-gray-700 mb-1 manual-input-markdown-label">
                            Paste LLM Output Here:
                        </label>
                        <textarea id="manualMarkdownInput" rows="10"
                            class="shadow-sm focus:ring-indigo-500 focus:border-indigo-500 mt-1 block w-full sm:text-sm border border-gray-300 rounded-md p-2 log-area"
                            placeholder="| Section | Q.X and Question | Answer | Instructions |\n|---|---|---|---|\n| ... | ... | ... | ... |"></textarea>
                    </div>
                    <button id="processManualInputBtn"
                        class="mt-4 bg-indigo-600 hover:bg-indigo-700 text-white font-medium py-2 px-4 rounded w-full sm:w-auto">
                        Parse and Display Manual Output
                    </button>
                </div>

                <div id="resultSection" class="hidden bg-white rounded-lg shadow-md p-6 mt-6">
                     <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4">
                        <h2 class="text-xl font-semibold text-gray-700 mb-2 sm:mb-0">3. Structured Results</h2>
                        <div class="space-x-2 flex">
                            <button id="exportCsv" class="bg-green-600 hover:bg-green-700 text-white font-medium py-2 px-4 rounded text-sm disabled:opacity-50" disabled>
                                Export CSV
                            </button>
                            <button id="exportExcel" class="bg-green-600 hover:bg-green-700 text-white font-medium py-2 px-4 rounded text-sm disabled:opacity-50" disabled>
                                Export Excel
                            </button>
                        </div>
                    </div>
                    <div class="table-container">
                        <table id="resultTable" class="min-w-full divide-y divide-gray-200">
                            <thead class="bg-gray-50">
                                <tr>
                                    <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-1/5">Section</th>
                                    <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-2/5">Q.X and Question</th>
                                    <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-1/5">Answer</th>
                                    <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-1/5">Instructions</th>
                                </tr>
                            </thead>
                            <tbody id="resultBody" class="bg-white divide-y divide-gray-200">
                            </tbody>
                        </table>
                    </div>
                     <div id="noResultsMessage" class="text-center py-4 text-gray-500 hidden">
                        No data could be structured.
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@2.16.105/build/pdf.worker.min.js';

        let DEBUG_MODE = true; 
        let selectedFile = null;
        let extractedData = [];
        let currentPdfFile = null;

        const dropArea = document.getElementById('dropArea');
        const fileInput = document.getElementById('fileInput');
        const fileInfo = document.getElementById('fileInfo');
        const fileNameElem = document.getElementById('fileName');
        const removeFile = document.getElementById('removeFile');
        const transcribeBtn = document.getElementById('transcribeBtn');
        const processingIndicator = document.getElementById('processingIndicator');
        const processingStatus = document.getElementById('processingStatus');
        const processingSubStatus = document.getElementById('processingSubStatus');
        const progressBarContainer = document.getElementById('progressBarContainer');
        const resultSection = document.getElementById('resultSection');
        const resultBody = document.getElementById('resultBody');
        const noResultsMessage = document.getElementById('noResultsMessage');
        const errorMessage = document.getElementById('errorMessage');
        const exportCsv = document.getElementById('exportCsv');
        const exportExcel = document.getElementById('exportExcel');
        const forceOcrCheckbox = document.getElementById('forceOcrCheckbox');
        const enableLayoutAnalysisCheckbox = document.getElementById('enableLayoutAnalysisCheckbox');
        const showOcrBlocksCheckbox = document.getElementById('showOcrBlocksCheckbox');
        const memoryWarningDiv = document.getElementById('memoryWarning');
        const ocrUnsupportedDiv = document.getElementById('ocrUnsupported');
        const ocrPreviewContainer = document.getElementById('ocrPreviewContainer');
        const ocrPreviewCanvas = document.getElementById('ocrPreviewCanvas');
        const ocrPreviewPageInfo = document.getElementById('ocrPreviewPageInfo');
        const liveOcrTextEl = document.getElementById('liveOcrText');
        const transcriptionLogEl = document.getElementById('transcriptionLog');
        const llmPromptDisplayEl = document.getElementById('llmPromptDisplay');
        const llmModelSelectEl = document.getElementById('llmModelSelect'); 
        const llmLiveOutputContainerEl = document.getElementById('llmLiveOutputContainer');
        const llmLiveOutputEl = document.getElementById('llmLiveOutput');
        const processingModeSelectEl = document.getElementById('processingModeSelect');
        const manualMarkdownInputEl = document.getElementById('manualMarkdownInput');
        const processManualInputBtnEl = document.getElementById('processManualInputBtn');
        const manualInputLabelEl = document.getElementById('manualInputLabel');

        const DIRECT_STRUCTURE_PROMPT = `You will be provided with TEXT CONTENT that has been extracted from an exam paper (which might also include an answer key). Your task is to carefully analyze this text and organize the relevant information into a Markdown table with exactly four columns.
The required columns are:
Section: The name of the section identified in the text (e.g., 'Section A: Grammar', 'Section I: Comprehension (Open-ended)'). If no specific section name applies to a row, use '-'.
Q.X and Question: The question number (e.g., 'Q.1', 'Q.71') followed by the full text of the question itself, if one is present or clearly associated with that number in the provided text. If the row represents a general section header or instruction line without a specific question number, use '-'.
Answer: The corresponding answer for the question number, taken directly from the provided text (if an answer key section is present), with no explanation. If the row does not have a specific question/answer associated with it in the text, or no answer key is present for it, use '-'.
Instructions: Populate this column with the actual, specific instruction text found in the document text that is most relevant to that row or the block of questions/tasks the row belongs to. Do not just write the word 'Instruction'. For example, use text like 'Shade your answer (1, 2, 3 or 4) on the Optical Answer Sheet.' or 'Fill in each blank with a suitable word.' or 'Read this passage carefully and answer the questions 71 to 80.' Apply the relevant instruction text logically to the rows it pertains to. If no specific instruction applies to a row, use '-'.

The final output must be formatted as a plain text Markdown table.
Crucially: Ensure the output is ONLY the raw Markdown syntax for the table itself. Do absolutely NOT wrap the table in code fences (\`\`\`), format it as a code block, or use any formatting other than the plain text Markdown table structure. Do not include any introductory phrases like "Okay, here is the table:" or any concluding remarks.
`;

        const TAGGING_PROMPT = `You are a text segmentation assistant. Your task is to analyze the provided exam paper TEXT and divide it into distinct segments.
For each segment, assign one of the following types: 'SECTION_TITLE', 'INSTRUCTION', 'QUESTION_CONTENT', 'ANSWER_KEY_ENTRY', or 'PAGE_METADATA'.

Your output MUST be a valid JSON array of objects. Each object must have "type" and "content" keys.

TAG DEFINITIONS:
1.  'SECTION_TITLE': The main title or heading of a new section.
    Example: "Section A: Multiple Choice Questions", "Answer Key"
2.  'INSTRUCTION': Instructions for students.
    Example: "Read each question carefully.", "For questions 1-10, choose the best answer."
3.  'QUESTION_CONTENT': The entire text block for a single question, including its number, the question itself, and all its options if it's multiple choice.
    Example: "1. What is the capital of France?\n(A) London\n(B) Paris\n(C) Berlin"
4.  'ANSWER_KEY_ENTRY': A single line or entry from the answer key section, usually containing a question number and its answer.
    Example: "1. B", "Q2: Paris", "11) Option A"
5.  'PAGE_METADATA': Text that is not part of a section, instruction, question, or answer key entry. This includes school names, page numbers, "End of Paper", student name/class fields, etc.
    Example: "St. Hilda's Primary School", "Page 5 of 12", "Name: _________"

OUTPUT FORMAT (JSON ARRAY ONLY):
[
  { "type": "PAGE_METADATA", "content": "BP-225\nSt Hilda’s Primary School..." },
  { "type": "SECTION_TITLE", "content": "Section A: 20 Marks" },
  { "type": "INSTRUCTION", "content": "For questions 1 to 10, write your answer (1, 2, 3 or 4) in the bracket provided. [2 marks each)" },
  { "type": "QUESTION_CONTENT", "content": "1 Which ane of the following is a matter?\n\n(1) air\n(2) heat\n(3) shadow\n(4) lightning" },
  // ... more segments ...
  { "type": "SECTION_TITLE", "content": "Simplified Answer Key." },
  { "type": "ANSWER_KEY_ENTRY", "content": "1] 4" }
]

IMPORTANT:
- Respond with ONLY the JSON array. No other text, comments, or explanations (like <think> tags).
- Ensure the JSON is perfectly well-formed.
- Capture the FULL and EXACT text for each segment as it appears in the document.
- Process the document sequentially.
- If a segment of text could arguably fit multiple types, choose the most specific and encompassing one (e.g., prefer 'QUESTION_CONTENT' over 'INSTRUCTION' if it's clearly a question with embedded instructions for that question only).
- Be consistent with the defined "type" strings.
`;

        document.addEventListener('DOMContentLoaded', () => {
            if (DEBUG_MODE) console.log("DOM loaded");
            checkOcrCompatibility();
            transcribeBtn.disabled = true;
            setupDebugToggle();
            initializeOcrPreviewCanvas();
            updateActivePromptDisplay(); 
            resetLogAreas();

            enableLayoutAnalysisCheckbox.addEventListener('change', function() {
                showOcrBlocksCheckbox.disabled = !this.checked;
                if (!this.checked) showOcrBlocksCheckbox.checked = false;
            });
            if (!enableLayoutAnalysisCheckbox.checked) showOcrBlocksCheckbox.disabled = true;

            if(processingModeSelectEl) {
                processingModeSelectEl.addEventListener('change', updateActivePromptDisplay);
            }
            if(processManualInputBtnEl) {
                processManualInputBtnEl.addEventListener('click', handleManualInputProcessing);
            }
        });

        function updateActivePromptDisplay() {
            const selectedMode = processingModeSelectEl.value;
            if (selectedMode === 'directStructure') {
                llmPromptDisplayEl.textContent = DIRECT_STRUCTURE_PROMPT;
                manualInputLabelEl.className = 'block text-sm font-medium text-gray-700 mb-1 manual-input-markdown-label';
                manualMarkdownInputEl.placeholder = "| Section | Q.X and Question | Answer | Instructions |\n|---|---|---|---|\n| ... | ... | ... | ... |";
            } else if (selectedMode === 'tagAndAssemble') {
                llmPromptDisplayEl.textContent = TAGGING_PROMPT;
                manualInputLabelEl.className = 'block text-sm font-medium text-gray-700 mb-1 manual-input-json-label';
                manualMarkdownInputEl.placeholder = '[\n  { "type": "SECTION", "content": "Section A" },\n  { "type": "QUESTION", "content": "Q.1 ..." },\n  ...\n]';
            }
        }

        function initializeOcrPreviewCanvas() { 
            const ctx = ocrPreviewCanvas.getContext('2d');
            ocrPreviewCanvas.width = 600; ocrPreviewCanvas.height = 400;
            ctx.fillStyle = "#eee"; ctx.fillRect(0, 0, 600, 400);
            ctx.fillStyle = "#ccc"; ctx.textAlign = "center"; ctx.font = "16px Inter";
            ctx.fillText("OCR Preview Area", 300, 200);
        }
        function resetLogAreas() { 
            if (liveOcrTextEl) liveOcrTextEl.textContent = 'Waiting for page processing...';
            if (transcriptionLogEl) transcriptionLogEl.textContent = 'Full transcribed text (input to LLM Proxy) will appear here...\n';
            if (llmLiveOutputEl) llmLiveOutputEl.textContent = 'Waiting for LLM stream...';
            if (llmLiveOutputContainerEl) llmLiveOutputContainerEl.classList.add('hidden');
        }
        function appendToLog(message, isFullLog = false) {
            if (!transcriptionLogEl) return;
            if (isFullLog) { 
                transcriptionLogEl.textContent = message;
            } else { 
                if (transcriptionLogEl.textContent.startsWith('Full transcribed text')) {
                    transcriptionLogEl.textContent = ''; 
                }
                transcriptionLogEl.textContent += message;
            }
            transcriptionLogEl.scrollTop = transcriptionLogEl.scrollHeight;
        }
        function updateLiveOcrTextDisplay(pageData, currentPage, totalPages) { 
             if (!liveOcrTextEl) return;
            if (!pageData) {
                liveOcrTextEl.textContent = `Page ${currentPage}/${totalPages}: No text data for live preview.`;
                return;
            }
            let displayText = `Page ${currentPage} of ${totalPages} - Live Output:\n====================================\n`;
            const textToDisplay = pageData.text || (typeof pageData === 'string' ? pageData : "No text extracted.");
            displayText += textToDisplay;
            if (pageData.blocks && showOcrBlocksCheckbox.checked && enableLayoutAnalysisCheckbox.checked) {
                displayText += `\n\n--- Detected Blocks (Top ${Math.min(5, pageData.blocks.length)}) --- (Conf: ${pageData.confidence?.toFixed(0) || 'N/A'}%)\n`;
                pageData.blocks.slice(0, 5).forEach((block, index) => {
                    displayText += `Block ${index + 1} (conf: ${block.confidence?.toFixed(0) || 'N/A'}%): "${(block.text || '').substring(0, 70).replace(/\n/g, ' ')}..."\n`;
                });
                if (pageData.blocks.length > 5) displayText += `... and ${pageData.blocks.length - 5} more blocks.\n`;
            }
            liveOcrTextEl.textContent = displayText;
            liveOcrTextEl.scrollTop = 0;
        }
        function setupDebugToggle() { 
            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' || DEBUG_MODE) {
                const btn = document.createElement('button'); btn.id = 'debugToggle';
                btn.textContent = `Debug: ${DEBUG_MODE ? 'ON' : 'OFF'}`;
                btn.onclick = () => { DEBUG_MODE = !DEBUG_MODE; btn.textContent = `Debug: ${DEBUG_MODE ? 'ON' : 'OFF'}`; console.log('Debug Mode:', DEBUG_MODE); };
                document.body.appendChild(btn);
            }
        }
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(evt => dropArea.addEventListener(evt, e => { e.preventDefault(); e.stopPropagation(); }, false));
        ['dragenter', 'dragover'].forEach(evt => dropArea.addEventListener(evt, () => dropArea.classList.add('active'), false));
        ['dragleave', 'drop'].forEach(evt => dropArea.addEventListener(evt, () => dropArea.classList.remove('active'), false));
        dropArea.addEventListener('drop', e => handleFiles(e.dataTransfer.files), false);
        dropArea.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', e => handleFiles(e.target.files));
        removeFile.addEventListener('click', resetFileInput);
        function handleFiles(files) { 
            if (DEBUG_MODE) console.log("handleFiles:", files);
            if (files.length > 0 && files[0].type === 'application/pdf') {
                currentPdfFile = files[0]; selectedFile = files[0];
                fileInfo.classList.remove('hidden'); fileNameElem.textContent = files[0].name;
                transcribeBtn.disabled = false; hideError(); resultSection.classList.add('hidden');
                resultBody.innerHTML = ''; noResultsMessage.classList.add('hidden');
                exportCsv.disabled = true; exportExcel.disabled = true;
                ocrPreviewContainer.classList.add('hidden'); 
                resetLogAreas();
            } else { showError('Please select a PDF file.'); resetFileInput(); }
        }
        function resetFileInput() { 
            fileInput.value = ''; selectedFile = null; currentPdfFile = null;
            fileInfo.classList.add('hidden'); fileNameElem.textContent = '';
            transcribeBtn.disabled = true; hideError(); resultSection.classList.add('hidden');
            resultBody.innerHTML = ''; noResultsMessage.classList.add('hidden');
            exportCsv.disabled = true; exportExcel.disabled = true;
            hideOcrPreview(); 
            resetLogAreas();
        }
        function showProcessingIndicator(statusMsg, subStatus = '', progress = null) {
            processingStatus.textContent = statusMsg; processingSubStatus.textContent = subStatus;
            processingIndicator.classList.remove('hidden'); transcribeBtn.disabled = true;
            if(processManualInputBtnEl) processManualInputBtnEl.disabled = true; 
            const bar = document.getElementById('processingProgressBar'); if (bar) bar.remove();
            if (progress !== null && progress >= 0) {
                const pBar = document.createElement('div'); pBar.id = 'processingProgressBar';
                pBar.className = 'bg-blue-200 rounded h-2 mt-2 overflow-hidden';
                pBar.innerHTML = `<div class="bg-blue-500 h-full rounded" style="width:${progress}%"></div>`;
                progressBarContainer.appendChild(pBar);
                if (subStatus && !subStatus.includes('%') && progress > 0) processingSubStatus.textContent = `${subStatus} (${progress.toFixed(0)}%)`;
            } else progressBarContainer.innerHTML = '';
         }
        function hideProcessingIndicator() { 
            processingIndicator.classList.add('hidden'); progressBarContainer.innerHTML = '';
            if (currentPdfFile) transcribeBtn.disabled = false; // Only enable if a file is selected
            else transcribeBtn.disabled = true;
            if(processManualInputBtnEl) processManualInputBtnEl.disabled = false;
        }
        function showError(msg) { 
            const dMsg = msg || 'An error occurred.';
            errorMessage.querySelector('p').textContent = dMsg; errorMessage.classList.remove('hidden');
            errorMessage.scrollIntoView({ behavior: 'smooth', block: 'center' });
            if (DEBUG_MODE) console.error("showError:", dMsg);
        }
        function hideError() { 
            errorMessage.classList.add('hidden'); errorMessage.querySelector('p').textContent = '';
        }
        function showOcrPreview(imgUrl, current, total, ocrBlocksData = null) { 
            if (DEBUG_MODE) console.log(`OCR preview page ${current}/${total}`, ocrBlocksData ? "with blocks" : "");
            const canvas = ocrPreviewCanvas, ctx = canvas.getContext('2d'), img = new Image();
            img.onload = () => {
                canvas.width = img.width; canvas.height = img.height;
                ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.drawImage(img, 0, 0);
                if (showOcrBlocksCheckbox.checked && enableLayoutAnalysisCheckbox.checked && ocrBlocksData?.blocks) {
                    ctx.strokeStyle = 'rgba(255,0,0,0.6)'; ctx.lineWidth = 2;
                    ocrBlocksData.blocks.forEach(b => { if (b.bbox) ctx.strokeRect(b.bbox.x0, b.bbox.y0, b.bbox.x1 - b.bbox.x0, b.bbox.y1 - b.bbox.y0); });
                }
            };
            img.onerror = () => { console.error("Preview image load fail."); initializeOcrPreviewCanvas(); ctx.fillText("Error loading preview", 300,200);};
            img.src = imgUrl;
            ocrPreviewPageInfo.textContent = `Page ${current} of ${total}`;
            ocrPreviewContainer.classList.remove('hidden');
        }
        function hideOcrPreview() { 
            ocrPreviewContainer.classList.add('hidden'); initializeOcrPreviewCanvas(); ocrPreviewPageInfo.textContent = 'Page X of Y';
        }
        function checkOcrCompatibility() { 
            if (navigator.deviceMemory && navigator.deviceMemory < 4) memoryWarningDiv.classList.remove('hidden');
            const ocrSettingsElements = [forceOcrCheckbox, enableLayoutAnalysisCheckbox, showOcrBlocksCheckbox, document.getElementById('llmModelOptions')]; 
            if (typeof WebAssembly === 'undefined') {
                ocrUnsupportedDiv.classList.remove('hidden');
                ocrSettingsElements.forEach(el => { 
                    if(el) {
                        el.disabled = true;
                        if(el.tagName === 'DIV') el.classList.add('opacity-50', 'pointer-events-none');
                    }
                });
            }
        }
        function determineOptimalOcrScale(size) { 
            return size > 30e6 ? 1.0 : (size > 10e6 ? 1.5 : 2.0);
        }

        transcribeBtn.addEventListener('click', async () => {
            if (DEBUG_MODE) console.log("Transcribe button clicked.");
            if (!currentPdfFile) { showError('Please select a PDF file.'); return; }
            
            resetLogAreas(); 
            hideError();
            resultSection.classList.add('hidden'); 
            extractedData = [];

            try {
                showProcessingIndicator('Starting PDF transcription...');
                
                const pdfContentData = await extractTextFromPdf(currentPdfFile, {
                    forceOcr: forceOcrCheckbox.checked,
                    ocrScale: determineOptimalOcrScale(currentPdfFile.size),
                    enableLayoutAnalysis: enableLayoutAnalysisCheckbox.checked
                });

                const rawFullText = (typeof pdfContentData === 'object' && pdfContentData.text) ? pdfContentData.text : (typeof pdfContentData === 'string' ? pdfContentData : '');
                appendToLog(rawFullText || "No text extracted from PDF to send to LLM Proxy.", true);  

                if (rawFullText && rawFullText.trim().length > 0) {
                    const selectedLlmModel = llmModelSelectEl.value;
                    const currentProcessingMode = processingModeSelectEl.value;
                    let activePrompt = (currentProcessingMode === 'tagAndAssemble') ? TAGGING_PROMPT : DIRECT_STRUCTURE_PROMPT;
                    
                    if (DEBUG_MODE) console.log("Processing Mode:", currentProcessingMode, "Using Prompt:", activePrompt.substring(0,100)+"...");
                    
                    await callLlmToStructureData(rawFullText, activePrompt, selectedLlmModel, currentProcessingMode);
                } else {
                    if (DEBUG_MODE) console.warn("No text extracted from PDF to process.");
                    showError('Could not extract text from PDF. Cannot proceed with LLM structuring.');
                    noResultsMessage.textContent = "No text extracted from PDF to send to LLM.";
                    noResultsMessage.classList.remove('hidden');
                    resultSection.classList.add('hidden'); 
                    exportCsv.disabled = true; exportExcel.disabled = true;
                    hideProcessingIndicator(); 
                }
            } catch (error) {
                console.error('Transcription/Structuring error:', error);
                showError(error.name === 'OcrError' ? (error.message || 'OCR failed.') : `Error: ${error.message || 'Unknown error'}`);
                resultSection.classList.add('hidden');
                llmLiveOutputContainerEl.classList.add('hidden');
                exportCsv.disabled = true; exportExcel.disabled = true;
                hideProcessingIndicator(); 
            }
        });

        async function extractTextFromPdf(file, options = {}) { 
            if (DEBUG_MODE) console.log("extractTextFromPdf. Options:", options);
            const { forceOcr, ocrScale, enableLayoutAnalysis } = options;
            let pdf = null;
            let fullTextReturn = { text: '', pages: [], containsOcrData: false, rawPageTexts: [] };
            try {
                showProcessingIndicator("Initializing PDF processor...");
                const arrayBuffer = await file.arrayBuffer();
                pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                const numPages = pdf.numPages;
                if (DEBUG_MODE) console.log(`PDF loaded: ${numPages} pages.`);
                showProcessingIndicator(`Loaded PDF: ${numPages} pages.`);
                let combinedTextForAllPages = ""; 
                for (let i = 1; i <= numPages; i++) {
                    const pageProgress = ((i - 1) / numPages) * 100;
                    showProcessingIndicator(`Processing page ${i}/${numPages}...`, `Page ${i}/${numPages}`, pageProgress);
                    const page = await pdf.getPage(i);
                    let pageTextContent = ''; 
                    try {
                        const textContent = await page.getTextContent();
                        pageTextContent = textContent.items.map(item => item.str).join(' ').trim();
                    } catch (textError) { console.warn(`Native text extraction failed page ${i}:`, textError); }
                    const requiresOcr = forceOcr || (!pageTextContent && enableLayoutAnalysis) || (pageTextContent.length < 50 && forceOcr);
                    let imageDataForPreview, pageSpecificDataForLog;
                    if (requiresOcr) {
                        fullTextReturn.containsOcrData = true;
                        if (DEBUG_MODE) console.log(`Page ${i}: Running OCR (scale: ${ocrScale}x).`);
                        const ocrViewport = page.getViewport({ scale: ocrScale });
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = Math.floor(ocrViewport.width); tempCanvas.height = Math.floor(ocrViewport.height);
                        await page.render({ canvasContext: tempCanvas.getContext('2d'), viewport: ocrViewport }).promise;
                        imageDataForPreview = tempCanvas.toDataURL('image/png');
                        const ocrResult = await performOcr(imageDataForPreview, i, numPages);
                        pageTextContent = ocrResult.text || ""; 
                        pageSpecificDataForLog = ocrResult; 
                        tempCanvas.width = 0; tempCanvas.height = 0;
                    } else {
                        if (DEBUG_MODE) console.log(`Page ${i}: Using native text.`);
                        pageSpecificDataForLog = { text: pageTextContent }; 
                        const displayViewport = page.getViewport({ scale: Math.min(1.5, ocrScale) }); 
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = Math.floor(displayViewport.width); tempCanvas.height = Math.floor(displayViewport.height);
                        await page.render({ canvasContext: tempCanvas.getContext('2d'), viewport: displayViewport }).promise;
                        imageDataForPreview = tempCanvas.toDataURL('image/png');
                        tempCanvas.width = 0; tempCanvas.height = 0;
                    }
                    combinedTextForAllPages += pageTextContent + "\n\n"; 
                    if(enableLayoutAnalysis && requiresOcr) fullTextReturn.pages.push({ pageNumber: i, ocrData: pageSpecificDataForLog });
                    else if(enableLayoutAnalysis) fullTextReturn.pages.push({ pageNumber: i, nativeText: pageTextContent });
                    updateLiveOcrTextDisplay(pageSpecificDataForLog, i, numPages); 
                    if (imageDataForPreview) showOcrPreview(imageDataForPreview, i, numPages, requiresOcr && enableLayoutAnalysis ? pageSpecificDataForLog : null);
                    page.cleanup();
                }
                fullTextReturn.text = combinedTextForAllPages.trim();
                if (DEBUG_MODE) console.log("extractTextFromPdf finished. Total text length:", fullTextReturn.text.length);
                return enableLayoutAnalysis ? fullTextReturn : fullTextReturn.text;
            } catch (error) {
                console.error('PDF processing error:', error);
                if (pdf) try { pdf.destroy(); } catch (e) { console.error("PDF destroy error", e); }
                throw new Error(`Failed to process PDF: ${error.message || String(error)}`);
            }
        }
        async function performOcr(imageData, currentPage, totalPages) { 
             if (DEBUG_MODE) console.log(`performOcr page ${currentPage}/${totalPages}`);
            let worker = null;
            try {
                worker = await Tesseract.createWorker({
                    logger: m => {
                        let progress = (m.progress && typeof m.progress === 'number') ? m.progress * 100 : null;
                        if (DEBUG_MODE) console.log(`Tesseract (${currentPage}/${totalPages}): ${m.status}`, m.progress || '');
                        if (m.status && (m.status !== 'recognizing text' || (progress !== null && progress > 0 && progress < 100))) { 
                             showProcessingIndicator(`Processing page ${currentPage}/${totalPages}...`, `OCR: ${m.status}`, progress);
                        }
                    }
                });
                await worker.loadLanguage('eng'); await worker.initialize('eng');
                await worker.setParameters({ tessedit_pageseg_mode: Tesseract.PSM.AUTO_OSD, preserve_interword_spaces: '1' });
                const result = await worker.recognize(imageData);
                await worker.terminate(); worker = null;
                return result.data; 
            } catch (error) {
                console.error(`OCR Error page ${currentPage}:`, error);
                if (worker) try { await worker.terminate(); } catch (e) { console.error("Tesseract terminate error", e); }
                const ocrErr = new Error(`OCR failed page ${currentPage}: ${error.message || String(error)}`);
                ocrErr.name = 'OcrError'; ocrErr.originalError = error; throw ocrErr;
            }
        }

        async function callLlmToStructureData(rawText, activePrompt, selectedModel, currentProcessingMode) {
            const PROXY_URL = 'http://localhost:3001/api/llm-structure';
            const modelValue = selectedModel.toLowerCase();
            const isPotentiallyStreamable = modelValue.includes('ollama') || modelValue.includes('gemini');

            if (DEBUG_MODE) {
                console.log(`callLlmToStructureData: Model=${selectedModel}, Mode=${currentProcessingMode}, StreamableHint=${isPotentiallyStreamable}`);
                console.log("Raw text input to backend (length):", rawText.length);
                console.log("Active Prompt (first 100):", activePrompt.substring(0,100)+"...");
            }
            
            const selectedLlmModelText = llmModelSelectEl.options[llmModelSelectEl.selectedIndex].text;
            showProcessingIndicator(`Communicating with ${selectedLlmModelText}...`, isPotentiallyStreamable ? 'Attempting to stream...' : 'Waiting for response...');

            let llmRawOutput = ""; 

            try {
                const response = await fetch(PROXY_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Accept': 'text/event-stream, application/json' }, 
                    body: JSON.stringify({ rawText: rawText, llmPrompt: activePrompt, selectedModel: selectedModel })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: "Unknown error from proxy", details: { message: `Proxy server returned ${response.status}` } }));
                    showError(`LLM Proxy error (${response.status}): ${errorData.details?.message || errorData.error || 'Unknown proxy error'}`);
                    extractedData = parseMarkdownTableToObjects("| Error | Proxy Error | " + response.status + " | See Logs |\n|---|---|---|---|\n");
                    displayResults(extractedData);
                    return; 
                }

                const contentType = response.headers.get("Content-Type");
                if (contentType && contentType.includes("text/event-stream") && isPotentiallyStreamable) {
                    if (DEBUG_MODE) console.log("Received text/event-stream from server. Processing as stream.");
                    llmLiveOutputContainerEl.classList.remove('hidden');
                    llmLiveOutputContainerEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    llmLiveOutputEl.textContent = ''; 
                    processingSubStatus.textContent = 'Streaming response...';

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';

                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) { if (DEBUG_MODE) console.log("LLM Stream ended (reader.read done)."); break; }
                        
                        buffer += decoder.decode(value, { stream: true });
                        let events = buffer.split('\n\n'); 
                        buffer = events.pop() || ''; 
                        for (const eventStr of events) {
                            if (eventStr.trim() === '') continue;
                            const dataLines = eventStr.split('\n').filter(l => l.startsWith('data: '));
                            for (const dataLine of dataLines) {
                                try {
                                    const jsonData = JSON.parse(dataLine.substring(6).trim()); 
                                    if (jsonData.type === 'chunk' && typeof jsonData.content === 'string') {
                                        llmLiveOutputEl.textContent += jsonData.content;
                                        llmRawOutput += jsonData.content;
                                        llmLiveOutputEl.scrollTop = llmLiveOutputEl.scrollHeight;
                                    } else if (jsonData.type === 'done') { /* Handled by reader.done */ } 
                                    else if (jsonData.type === 'error') { showError(`LLM Stream Error: ${jsonData.message}`); }
                                } catch (e) { if (DEBUG_MODE) console.warn("Error parsing SSE data line:", dataLine, e); }
                            }
                        }
                    }
                     if (buffer.trim().startsWith('data: ')) { 
                        try {
                            const jsonData = JSON.parse(buffer.substring(6).trim());
                            if (jsonData.type === 'chunk' && typeof jsonData.content === 'string') {
                                llmLiveOutputEl.textContent += jsonData.content;
                                llmRawOutput += jsonData.content;
                            }
                        } catch (e) { /* ignore if incomplete */ }
                    }
                } else {
                    if (DEBUG_MODE) console.log("Received non-streaming response. Content-Type:", contentType);
                    llmLiveOutputContainerEl.classList.add('hidden'); 
                    const responseText = await response.text();
                    llmRawOutput = responseText;
                }
                
                processingSubStatus.textContent = 'Processing LLM output...';
                if (currentProcessingMode === 'directStructure') {
                    if (DEBUG_MODE) console.log("Processing as directStructure. Raw Output (first 500):", llmRawOutput.substring(0,500));
                    let cleanedMarkdown = llmRawOutput;
                    const markdownTableMatch = cleanedMarkdown.match(/(\|(?:[^\r\n\|]+\|)+[\r\n]+)((?:\|(?:[-:]+\|)+[\r\n]+))((?:\|(?:[^\r\n\|]+\|)+[\r\n]*)+)/);
                    if (markdownTableMatch && markdownTableMatch[0]) {
                        cleanedMarkdown = markdownTableMatch[0];
                        if (DEBUG_MODE) console.log("Extracted potential Markdown table from raw output.");
                    } else {
                        cleanedMarkdown = cleanedMarkdown.replace(/<think>[\s\S]*?<\/think>/g, '').trim();
                        cleanedMarkdown = cleanedMarkdown.replace(/^```markdown\s*[\r\n]?([\s\S]*?)[\r\n]?```$/mg, '$1').trim();
                        cleanedMarkdown = cleanedMarkdown.replace(/^```\s*[\r\n]?([\s\S]*?)[\r\n]?```$/mg, '$1').trim();
                        if (DEBUG_MODE) console.log("Attempted to clean non-table Markdown output.");
                    }
                    extractedData = parseMarkdownTableToObjects(cleanedMarkdown);

                } else if (currentProcessingMode === 'tagAndAssemble') {
                    if (DEBUG_MODE) console.log("Processing as tagAndAssemble. Raw Output (first 500):", llmRawOutput.substring(0,500));
                    let jsonString = llmRawOutput;
                    const jsonMatch = jsonString.match(/(\[[\s\S]*\])/); 
                    if (jsonMatch && jsonMatch[1]) {
                        jsonString = jsonMatch[1];
                        if (DEBUG_MODE) console.log("Extracted potential JSON array from raw output:", jsonString.substring(0, 200) + "...");
                    } else {
                        if (DEBUG_MODE) console.log("Could not find clear JSON array with [...]. Attempting to clean common tags.");
                        jsonString = jsonString.replace(/<think>[\s\S]*?<\/think>/g, '').trim();
                        jsonString = jsonString.replace(/^```json\s*[\r\n]?([\s\S]*?)[\r\n]?```$/mg, '$1').trim();
                        jsonString = jsonString.replace(/^```\s*[\r\n]?([\s\S]*?)[\r\n]?```$/mg, '$1').trim();
                        jsonString = jsonString.replace(/^Okay, here's the JSON array:\s*[\r\n]*/i, '').trim();
                        jsonString = jsonString.replace(/^Here is the JSON output:\s*[\r\n]*/i, '').trim();
                    }
                    try {
                        const taggedDataArray = JSON.parse(jsonString);
                        if (!Array.isArray(taggedDataArray)) throw new Error("Extracted content for tagging was not a JSON array.");
                        extractedData = assembleTableFromTaggedData(taggedDataArray);
                    } catch (e) {
                        console.error("Error parsing or assembling tagged JSON output:", e, "\nCleaned JSON String Attempt:", jsonString.substring(0,1000), "\nOriginal Raw Output:", llmRawOutput.substring(0,1000));
                        showError(`Failed to process tagged output: ${e.message}. Expected JSON. Check console and LLM's raw output.`);
                        extractedData = [];
                    }
                }
                displayResults(extractedData);
                if (resultSection && !resultSection.classList.contains('hidden')) resultSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                else if (!llmLiveOutputContainerEl.classList.contains('hidden') && llmLiveOutputEl.textContent.trim() !== 'Waiting for LLM stream...') llmLiveOutputContainerEl.scrollIntoView({behavior: 'smooth', block: 'start'});

            } catch (error) {
                console.error('Error in callLlmToStructureData (fetch or processing):', error);
                showError(`LLM Comms/Processing Error: ${error.message}. Check backend console.`);
                extractedData = parseMarkdownTableToObjects("| Error | Processing | LLM | Failed |\n|---|---|---|---|\n");
                displayResults(extractedData);
                llmLiveOutputContainerEl.classList.add('hidden');
            } finally {
                hideProcessingIndicator();
            }
        }
        
        function parseMarkdownTableToObjects(markdownTableString) { 
            if (DEBUG_MODE) console.log("Parsing Markdown Table (Raw Input String):\n---\n" + markdownTableString + "\n---");
            const objects = [];
            if (!markdownTableString || typeof markdownTableString !== 'string' || markdownTableString.trim() === '' || markdownTableString.startsWith("| Error |")) {
                if (DEBUG_MODE) console.error("Markdown input is invalid, empty, indicates an error from LLM/Proxy, or is just whitespace.");
                return objects;
            }
            const lines = markdownTableString.trim().split(/\r?\n/).map(line => line.trim()).filter(line => line.length > 0);
            if (lines.length < 2) { 
                if (DEBUG_MODE) console.warn("Markdown table has too few non-empty lines to parse. Lines found:", lines);
                return objects;
            }
            let headerLineIndex = -1;
            for(let i=0; i < lines.length; i++) { if(lines[i].startsWith('|') && lines[i].endsWith('|') && lines[i].includes('|')) { headerLineIndex = i; break; } }
            if (headerLineIndex === -1) { if (DEBUG_MODE) console.warn("No valid header line found."); return objects; }
            const headerLine = lines[headerLineIndex];
            if (DEBUG_MODE) console.log("Identified Header Line (index " + headerLineIndex + "):", headerLine);
            let separatorLineIndex = -1;
            for (let i = headerLineIndex + 1; i < lines.length; i++) { if (lines[i].match(/^\|?[-:| ]+\|?$/) && lines[i].includes('-') && lines[i].includes('|')) { separatorLineIndex = i; break; } }
            if (separatorLineIndex === -1) { if (DEBUG_MODE) console.warn("No valid separator line found after header."); return objects; }
            if (DEBUG_MODE) console.log("Identified Separator Line (index " + separatorLineIndex + "):", lines[separatorLineIndex]);
            let rawHeaders = headerLine;
            if (rawHeaders.startsWith('|')) rawHeaders = rawHeaders.substring(1);
            if (rawHeaders.endsWith('|')) rawHeaders = rawHeaders.substring(0, rawHeaders.length - 1);
            const headers = rawHeaders.split('|').map(h => h.trim());
            if (DEBUG_MODE) console.log("Raw Headers Extracted:", headers);
            const expectedHeadersMap = {
                section: 'section', qxandquestion: 'questionText', questionnumberandquestion: 'questionText', 
                questiontext: 'questionText', question: 'questionText', answer: 'answer', 
                instructions: 'instructions', instruction: 'instructions'
            };
            const columnMap = headers.map(h_raw => {
                const h_cleaned = h_raw.toLowerCase().replace(/[^a-z0-9]/gi, '');
                for (const key in expectedHeadersMap) { if (h_cleaned === key || (h_cleaned.length > 2 && key.includes(h_cleaned)) || (key.length > 2 && h_cleaned.includes(key))) { return expectedHeadersMap[key]; } }
                if (DEBUG_MODE) console.warn(`Unknown header "${h_raw}" (cleaned: "${h_cleaned}") encountered. Will use as is: "${h_raw.replace(/\s+/g, '_')}"`);
                return h_raw.replace(/\s+/g, '_') || `unknown_column_${Math.random().toString(36).substring(7)}`;
            });
            if (DEBUG_MODE) console.log("Effective column map for parsing:", columnMap, "based on headers:", headers);
            for (let i = separatorLineIndex + 1; i < lines.length; i++) {
                const line = lines[i]; 
                if (!line.startsWith('|') || !line.endsWith('|') || !line.includes('|')) { if (DEBUG_MODE && line.length > 0) console.warn("Skipping line (not valid table row):", `"${line}"`); continue; }
                if (line.match(/^\|?[-:| ]+\|?$/) && line.includes('-')) { if (DEBUG_MODE) console.log("Skipping potential duplicate separator line:", `"${line}"`); continue; }
                const values = line.substring(1, line.length - 1).split('|').map(v => v.trim());
                if (values.length !== headers.length) { if (DEBUG_MODE) console.warn(`Skipping row: column count mismatch. Expected ${headers.length}, got ${values.length}. Line: "${line}"`); continue; }
                const obj = {};
                let hasData = false;
                for (let j = 0; j < columnMap.length; j++) {
                    const keyToUse = columnMap[j]; 
                    const value = values[j] !== undefined ? values[j] : '';
                    obj[keyToUse] = value;
                    if (value && value !== '-' && value.trim() !== '') { hasData = true; }
                }
                ['section', 'questionText', 'answer', 'instructions'].forEach(expectedKey => { if (!obj.hasOwnProperty(expectedKey)) { obj[expectedKey] = '-'; } });
                if (hasData || Object.values(obj).some(val => val && val !== '-' && val.trim() !== '')) { if (DEBUG_MODE) console.log("Parsed Row Data:", JSON.stringify(obj)); objects.push(obj); } 
                else { if (DEBUG_MODE) console.log("Skipping row (no significant data):", JSON.stringify(obj), `Original line: "${line}"`); }
            }
            if (DEBUG_MODE) console.log("Final Parsed objects from markdown:", objects);
            if (objects.length === 0 && lines.length > separatorLineIndex + 1) { if (DEBUG_MODE) console.warn("Parsing completed, but no data objects were created from available lines after separator."); }
            return objects;
        }
        
        function assembleTableFromTaggedData(taggedDataArray) {
            if (DEBUG_MODE) console.log("Assembling table from tagged data:", taggedDataArray);
            const assembledRows = [];
            if (!Array.isArray(taggedDataArray)) {
                console.error("Input to assembleTableFromTaggedData is not an array.");
                showError("Tagged data from LLM was not a valid JSON array.");
                return assembledRows;
            }

            let currentSection = "-";
            let currentInstructionContext = "-"; 
            let currentRow = null; 

            function createNewRow() {
                return { section: currentSection, questionText: "-", answer: "-", instructions: currentInstructionContext };
            }
            
            function finalizeAndPushRow(rowToPush) {
                if (rowToPush && (rowToPush.questionText !== "-" || rowToPush.answer !== "-" || (rowToPush.instructions !== "-" && rowToPush.instructions !== currentInstructionContext) )) {
                    assembledRows.push({ ...rowToPush });
                     if (DEBUG_MODE) console.log("Finalized Row:", rowToPush);
                } else if (rowToPush && DEBUG_MODE) {
                     console.log("Skipping empty/default row:", rowToPush);
                }
            }

            for (const item of taggedDataArray) {
                if (!item || typeof item.type !== 'string' || typeof item.content !== 'string') {
                    if (DEBUG_MODE) console.warn("Skipping invalid tagged item:", item);
                    continue;
                }

                const type = item.type.toUpperCase();
                const content = item.content.trim();
                if (content === "") continue;

                switch (type) {
                    case 'SECTION':
                        if (currentRow) finalizeAndPushRow(currentRow); 
                        currentSection = content;
                        currentInstructionContext = "-"; 
                        currentRow = null; 
                        if (DEBUG_MODE) console.log(`New Section Context: ${currentSection}`);
                        break;

                    case 'INSTRUCTION':
                        if (currentRow && currentRow.questionText !== "-") {
                            currentRow.instructions = (currentRow.instructions === "-" || currentRow.instructions === currentInstructionContext) ? content : `${currentRow.instructions}\n${content}`;
                        } else {
                            currentInstructionContext = content;
                            // If an instruction appears and there's no active question row,
                            // we hold this instruction context. If a SECTION tag appears next, it gets reset.
                            // If a QUESTION tag appears next, this instruction will be applied.
                            // If another INSTRUCTION or ANSWER appears, this could lead to complex scenarios.
                            // A simple approach is to also create a row for standalone instructions if needed later.
                        }
                        if (DEBUG_MODE) console.log(`Instruction found: "${content}". Current row:`, currentRow, `Context Instruction: ${currentInstructionContext}`);
                        break;

                    case 'QUESTION':
                        if (currentRow) finalizeAndPushRow(currentRow); 
                        currentRow = createNewRow(); // Applies currentSection & currentInstructionContext
                        currentRow.questionText = content;
                        if (DEBUG_MODE) console.log(`Question started: "${content}". Row:`, currentRow);
                        break;

                    case 'ANSWER':
                        if (currentRow && currentRow.questionText !== "-") { 
                            currentRow.answer = (currentRow.answer === "-") ? content : `${currentRow.answer}\n${content}`;
                        } else { 
                            if (DEBUG_MODE) console.warn(`Orphan Answer: "${content}". Creating new row for it.`);
                            if (currentRow) finalizeAndPushRow(currentRow); // Finalize any previous partial content
                            currentRow = createNewRow(); // Create a new row for this orphan answer
                            currentRow.answer = content;
                            // We might finalize this orphan answer row immediately or wait.
                            // For simplicity, let's assume an answer without a question is a data point to capture.
                        }
                        if (DEBUG_MODE) console.log(`Answer found: "${content}". Row:`, currentRow);
                        break;
                    
                    default:
                        if (DEBUG_MODE) console.warn("Unknown tag type:", type, "Content:", content);
                }
            }
            if (currentRow) {
                finalizeAndPushRow(currentRow);
            }

            if (DEBUG_MODE) console.log("Assembled rows from tagged data:", assembledRows);
            return assembledRows;
        }

        function displayResults(data) { 
            if (DEBUG_MODE) console.log("displayResults data:", data);
            resultBody.innerHTML = ''; 
            
            if (!data || data.length === 0) {
                noResultsMessage.textContent = "No structured data could be parsed or displayed.";
                noResultsMessage.classList.remove('hidden');
                resultSection.classList.add('hidden'); 
                exportCsv.disabled = true; exportExcel.disabled = true;
            } else {
                noResultsMessage.classList.add('hidden');
                resultSection.classList.remove('hidden'); 
                data.forEach(item => {
                    const row = resultBody.insertRow();
                    row.insertCell().textContent = item.section || '-'; 
                    row.insertCell().textContent = item.questionText || '-';
                    row.insertCell().textContent = item.answer || '-';
                    row.insertCell().textContent = item.instructions || '-';
                    Array.from(row.cells).forEach(cell => cell.className = 'px-6 py-4 whitespace-normal text-sm text-gray-700 break-words');
                });
                exportCsv.disabled = false; exportExcel.disabled = false;
            }
        }
        function exportToCsv(filename, rows) { 
             const header = ["Section", "Q.X and Question", "Answer", "Instructions"]; 
            const csvContent = [
                header.join(','),
                ...rows.map(r => [
                    `"${(r.section || '-').replace(/"/g, '""')}"`,
                    `"${(r.questionText || '-').replace(/"/g, '""')}"`,
                    `"${(r.answer || '-').replace(/"/g, '""')}"`,
                    `"${(r.instructions || '-').replace(/"/g, '""')}"`
                ].join(','))
            ].join('\n');
            const blob = new Blob(["\uFEFF" + csvContent], { type: 'text/csv;charset=utf-8;' }); 
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob); link.download = filename;
            document.body.appendChild(link); link.click(); document.body.removeChild(link);
        }
        function exportToExcel(filename, rows) { 
            const header = ["Section", "Q.X and Question", "Answer", "Instructions"];
            const dataToExport = rows.map(r => ({
                "Section": r.section || '-', 
                "Q.X and Question": r.questionText || '-',
                "Answer": r.answer || '-', 
                "Instructions": r.instructions || '-'
            }));
            const ws = XLSX.utils.json_to_sheet(dataToExport, {header: header}); 
            const wb = XLSX.utils.book_new(); XLSX.utils.book_append_sheet(wb, ws, "Results");
            XLSX.writeFile(wb, filename);
        }
        exportCsv.addEventListener('click', () => { 
             if (extractedData.length > 0) exportToCsv('llm_structured_results.csv', extractedData);
            else showError("No data to export.");
        });
        exportExcel.addEventListener('click', () => { 
            if (extractedData.length > 0) exportToExcel('llm_structured_results.xlsx', extractedData);
            else showError("No data to export.");
        });

        function handleManualInputProcessing() {
            const manualText = manualMarkdownInputEl.value;
            const currentProcessingMode = processingModeSelectEl.value;
            if (DEBUG_MODE) console.log("Process Manual Input. Mode:", currentProcessingMode, "Text length:", manualText.length);

            if (!manualText || manualText.trim() === '') {
                showError("Please paste LLM output into the manual input area.");
                return;
            }
            hideError(); 
            llmLiveOutputContainerEl.classList.add('hidden'); 
            processingIndicator.classList.add('hidden'); 
            resultSection.classList.add('hidden'); 

            try {
                let cleanedManualText = manualText;
                if (currentProcessingMode === 'directStructure') {
                    // Optional: clean manual markdown too if desired, similar to callLlmToStructureData
                    const markdownTableMatch = cleanedManualText.match(/(\|(?:[^\r\n\|]+\|)+[\r\n]+)((?:\|(?:[-:]+\|)+[\r\n]+))((?:\|(?:[^\r\n\|]+\|)+[\r\n]*)+)/);
                    if (markdownTableMatch && markdownTableMatch[0]) cleanedManualText = markdownTableMatch[0];
                    
                    extractedData = parseMarkdownTableToObjects(cleanedManualText);
                } else if (currentProcessingMode === 'tagAndAssemble') {
                    if (DEBUG_MODE) console.log("Attempting to parse manual input as JSON for tagging.")
                    let jsonStringToParse = cleanedManualText;
                    const jsonMatch = jsonStringToParse.match(/(\[[\s\S]*\])/); 
                    if (jsonMatch && jsonMatch[1]) jsonStringToParse = jsonMatch[1];

                    const taggedDataArray = JSON.parse(jsonStringToParse); 
                    if (!Array.isArray(taggedDataArray)) throw new Error("Manual input for 'Tag & Assemble' mode was not a valid JSON array.");
                    extractedData = assembleTableFromTaggedData(taggedDataArray);
                } else {
                    showError("Invalid processing mode selected for manual input.");
                    extractedData = []; 
                }
                
                if (DEBUG_MODE) console.log("Parsed objects from Manual Input:", extractedData);
                displayResults(extractedData);                 
                if (extractedData.length > 0) {
                    resultSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            } catch (parseError) {
                console.error("Error parsing manual input:", parseError);
                showError(`Error parsing manual input: ${parseError.message}. Ensure format matches selected mode.`);
                extractedData = [];
                displayResults(extractedData); 
            }
        }
    </script>
</body>
</html>